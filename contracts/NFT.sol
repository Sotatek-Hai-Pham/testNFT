// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "erc721a/contracts/ERC721A.sol";
import "./ChainlinkInfrastructureClient.sol";
import "./PausableMint.sol";
import "./Withdrawable.sol";
import "./interfaces/IERC20.sol";
import "./interfaces/IERC721.sol";
import "./interfaces/IERC721Metadata.sol";
import "./libs/SignerVerification.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./Royalty.sol";
import "hardhat/console.sol";


struct NFT {
	uint8 level; // 1-7
	/*
	 * COMMON PARTS
	 * value from 0 to n, where n - is max number of property,
	 * 10 (NULL) - absence of params
	 */
	uint8 color; // 0-4
	uint8 background; // 0-9
	uint8 necklace; // 0-9
	uint8 accessories; // 0-9
	uint8 weapon; //  0-9
}

contract TestNFT is
	ERC721A,
	ChainlinkInfrastructureClient,
	PausableMint,
	Withdrawable,
	Royalty,
	ReentrancyGuard {

	address private signer; // Address of presale signatures creator

	uint256 public publicSaleTimestamp;
	uint256 public preSaleTimestamp;

	uint256 public preSalePriceOfNFT = 0.000005 ether;
	uint256 public publicSalePriceOfNFT = 0.00001 ether;
	uint256 public discountedGirlDragonPrice = 0.0000075 ether;
	// uint256 public maxSupply = 10000

	uint256 public timestampOfSexChangeAtMint = 1661990400; // 1 sepetember 2022

	// Mapping of supported interfaces
	mapping(bytes4 => bool) private _supportedInterfaces;

	struct Upgrade {
		bool inProgress;
		uint256 timestamp;
	}

	// NFT properties by tokenId
	mapping(uint256 => NFT) internal Tokens;

	/*
	 * Requests to get update availability
	 * @param requestId - generated by Chainlink
	 * @return tokenId  - NFT ID
	 */
	mapping(bytes32 => uint256) private UpgradeRequests;

	/*
	 * Requests to get random number
	 * @param requestId - ID returned from request builder function
	 * @return tokenId - NFT ID
	 */
	mapping(uint256 => uint256[]) internal VRFRequests;

	/*
	 * Requests to get random number
	 * @param tokenId - NFT ID for what was request
	 * @return lastUpdateRequestTimestamp
	 */
	mapping(uint256 => Upgrade) internal LastUpgrades;

	/**
	 * Events
	 * @notice they are needed for backend to refresh data in DB and create/update NFT images
	 */
	event MintFinal(address owner, uint256 tokenId, uint8 gender, uint8 color);

	// Event for NFT that just have been upgraded
	event LevelUp(
		uint256 tokenId,
		uint8 level,
		uint8 gender,
		uint8 color,
		uint8 background,
		uint8 necklace,
		uint8 accessories,
		uint8 weapon,
		bool[9] roboParts
	);

	event UpgradeFailed(bytes32 requestId);

	constructor(
		ChainlinkVRFConfig memory _chainlinkVRFConfig,
		uint256 _preSalePriceOfNFT,
		uint256 _publicSalePriceOfNFT,
		uint256 _preSaleTimestamp,
		uint256 _publicSaleTimestamp,
		address royaltyReceiver
	)
		ChainlinkInfrastructureClient(_chainlinkVRFConfig)
		ERC721A("Test", "TTT")
		Royalty(royaltyReceiver)
	{
		preSalePriceOfNFT = _preSalePriceOfNFT;
		publicSalePriceOfNFT = _publicSalePriceOfNFT;

		preSaleTimestamp = _preSaleTimestamp;
		publicSaleTimestamp = _publicSaleTimestamp;

		signer = msg.sender;

		_registerInterface(_INTERFACE_ID_ERC2981);
		_registerInterface(type(IERC165).interfaceId);
		_registerInterface(type(IERC721).interfaceId);
		_registerInterface(type(IERC721Metadata).interfaceId);
	}

	/**
	 * Mints some quantity of NFTs on pre sale stage
	 * @param quantity of NFTs to mint
	 * @param signature address of msg.sender signed by owner of contract
	 * needed for WL
	 * @notice msg.value should be enough for mint, including NFT price (preSalePriceOfNFT * quantity)
	 * @notice presale should start, otherwise tx will be reverted
	 */
	function mintOnPreSale(uint256 quantity, bytes memory signature) external payable {
		require(_currentTime() > preSaleTimestamp, "Pre-sale is not started yet");

		// Verify signature
		require(
			SignerVerification.isMessageVerified(signer, signature, _addressToString(msg.sender)),
			"Presale signature is wrong"
		);
		require(msg.value >= preSalePriceOfNFT * quantity, "AAA: Not enough ethers to mint NFTs");

		_mint(quantity, msg.sender);
	}

	/**
	 * Mints some quantity of NFTs on public sale stage
	 * @param quantity of NFTs to mint
	 * @notice msg.value should be enough for mint, including NFT price (publicSalePriceOfNFT * quantity)
	 * @notice public sale should start, otherwise tx will be reverted
	 */
	function mintOnPublicSale(uint256 quantity) external payable {
		require(_currentTime() > publicSaleTimestamp, "Public sale is not started yet");
		require(msg.value >= publicSalePriceOfNFT * quantity, "AAA: Not enough ethers to mint NFTs");

		_mint(quantity, msg.sender);
	}


	/**
	 * Mints some quantity of NFTs
	 * @param quantity of NFTs to mint
	 * @param receiver address that will receive NFT
	 *
	 * @notice Mints not more than 10 NFTs by transaction
	 * @notice Can mint not more than 20 NFTs by account
	 */
	function _mint(uint256 quantity, address receiver) internal whenNotPaused {
		require(balanceOf(receiver) + quantity <= 20, "AAA: You are allowed to get only 20 NFTs");
		require(quantity <= 10, "AAA: You can mint only 10 mint in one transaction");

		uint256 startTokenId = _totalMinted();

		_safeMint(receiver, quantity);

		uint256 currentIndex = startTokenId;
		uint256[] memory mintedTokensIds = new uint256[](quantity);

		for(uint8 i = 0; i < quantity; ) {
			mintedTokensIds[i] = currentIndex;

			unchecked {
				currentIndex++;
				i++;
			}
		}

		_recordMintedTokens(mintedTokensIds);
	}

	function _recordMintedTokens(
		uint256 [] memory _ids
	) internal {
			_requestNFTPropsFullfillmentWithRandom(_ids);
		}

	/**
	 * Makes request to ChainlinkVRF for random number
	 * @param tokenIds NFT IDs with empty properties to fill in
	 */
	function _requestNFTPropsFullfillmentWithRandom(uint256[] memory tokenIds) internal {
		uint256 requestId = COORDINATOR.requestRandomWords(
			keyHash,
			subscriptionId,
			requestConfirmations,
			callbackGasLimit,
			6 // Count of random words
		);

		// Record requestId and tokenId pair to get that as context later (in fulfillRandomWords())
		VRFRequests[requestId] = tokenIds;

		for (uint8 i = 0; i < tokenIds.length; ) {
			LastUpgrades[tokenIds[i]] = Upgrade(true, _currentTime());
			unchecked {
				i++;
			}
		}
	}

	/**
	 * Called by Chainlink VRF to fill in missing NFT params with random words
	 * @param _requestId unique request identifier
	 * @param _randomWords - some big random numbers
	 * @dev function name can"t be changed! That is the standard name in Chainlink VRF
	 */
	function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
		uint256[] memory tokenIds = VRFRequests[_requestId];

		// Fill in every NFT properties with different parts of random word
		for (uint8 i = 0; i < tokenIds.length; ) {
			NFT storage token = Tokens[tokenIds[i]];

			uint256 randomLevel = _randomWords[0];
			uint256 randomColor = _randomWords[1];
			uint256 randomBackGround = _randomWords[2];
			uint256 randomNeck = _randomWords[3];
			uint256 randomAccessories = _randomWords[4];
			uint256 randomWeapon = _randomWords[5];
			
			unchecked {
				randomLevel = randomLevel << (i);
			}

			token.level = uint8((randomLevel % 8) + 1);

			unchecked {
				randomColor = randomColor << (i);
			}

			token.color = uint8((randomColor % 10));

			unchecked {
				randomNeck = randomNeck << (i);
			}

			token.necklace = uint8((randomNeck % 10));

			unchecked {
				randomBackGround = randomBackGround << (i);
			}

			token.background = uint8((randomBackGround % 10) + 1);

			unchecked {
				randomAccessories = randomAccessories << (i);
			}

			token.accessories = uint8((randomAccessories % 10));

			unchecked {
				randomWeapon = randomWeapon << (i);
			}

			token.weapon = uint8((randomWeapon % 10));

			unchecked {
				i++;
			}
		}

		// Clear requests mapping
		delete VRFRequests[_requestId];
	}



	/**
	 * Returns URL to token metadata
	 * @param tokenId ID of NFT to return URL
	 * @return string URI to backend or IPFS
	 * @dev Uses TokenURIManager to generate url
	 */
	function tokenURI(uint256 tokenId) public view override returns (string memory) {
		require(_exists(tokenId), "AAA: URI request for non existen token");


		return "";
	}

	/**
	 * @param tokenId ID of NFT
	 */
	function getTokenById(uint256 tokenId) external view returns (NFT memory) {
		return Tokens[tokenId];
	}

	/** Updates pre-sale price of NFT
	 * @param _preSalePriceOfNFT new pre-sale price for NFT
	 * @dev only owner of contract can change price
	 */
	function setPreSalePriceOfNFT(uint256 _preSalePriceOfNFT) external onlyOwner {
		preSalePriceOfNFT = _preSalePriceOfNFT;
	}

	/** Updates public sale price of NFT
	 * @param _publicSalePriceOfNFT public sale price for NFT
	 * @dev only owner of contract can change price
	 */
	function setPublicSalePriceOfNFT(uint256 _publicSalePriceOfNFT) external onlyOwner {
		publicSalePriceOfNFT = _publicSalePriceOfNFT;
	}

	function _registerInterface(bytes4 interfaceId) internal {
		_supportedInterfaces[interfaceId] = true;
	}

	function supportsInterface(bytes4 interfaceId) public view override(ERC721A, IERC165, ERC165) returns (bool) {
		return _supportedInterfaces[interfaceId];
	}


	function setPreSaleTimestamp(uint256 _preSaleTimestamp) external onlyOwner {
		preSaleTimestamp = _preSaleTimestamp;
	}

	function setPublicSaleTimestamp(uint256 _publicSaleTimestamp) external onlyOwner {
		publicSaleTimestamp = _publicSaleTimestamp;
	}

	function _addressToString(address _addr) internal pure returns (string memory) {
		bytes memory addressBytes = abi.encodePacked(_addr);

		bytes memory stringBytes = new bytes(42);

		stringBytes[0] = "0";
		stringBytes[1] = "x";

		for (uint256 i = 0; i < 20; ) {
			uint8 leftValue = uint8(addressBytes[i]) / 16;
			uint8 rightValue = uint8(addressBytes[i]) - 16 * leftValue;

			bytes1 leftChar = leftValue < 10 ? bytes1(leftValue + 48) : bytes1(leftValue + 87);
			bytes1 rightChar = rightValue < 10 ? bytes1(rightValue + 48) : bytes1(rightValue + 87);

			stringBytes[2 * i + 3] = rightChar;
			stringBytes[2 * i + 2] = leftChar;

			unchecked {
				i++;
			}
		}

		return string(stringBytes);
	}

	function _currentTime() internal view returns (uint64) {
		return uint64(block.timestamp);
	}
}